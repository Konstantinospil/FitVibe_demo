---
title: "FitVibe — Testing & Quality Assurance Plan"
version: "v3.0"
status: "Approved (MVP → GA baseline)"
review_cadence: "Per release and quarterly"
date: "2025-10-26"
license: "MIT"
---

# Appendix E — Metrics Contract Checklist

# E.1 Objectives

Define a **machine-verifiable contract** for app observability so that each build exposes the **required Prometheus metrics** with the correct **names, types, labels, and buckets**. CI must **fail** when the contract is not satisfied.

Hard gates:

- HTTP request histogram & counters exposed with standard labels.
- DB query histogram exposed with mandated buckets.
- RUM LCP gauge exposed from frontend collector.
- Scrape endpoints reachable and non-empty.
- Example series present for smoke routes with non-zero samples.

---

# E.2 Required Metrics (names, types, labels)

## E.2.1 HTTP Server

- **Name:** `http_request_duration_seconds` (Histogram)
  - **Labels (required):** `method`, `route`, `status_code`
  - **Buckets (mandated):** `0.05, 0.1, 0.2, 0.3, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 5`
  - **Objectives:** p50, p95, p99 via `histogram_quantile`
  - **Cardinality controls:** `route` must use **templated paths** (e.g., `/api/v1/sessions/{id}`)

- **Name:** `http_requests_total` (Counter)
  - **Labels:** `method`, `route`, `status_code`

- **Name:** `http_request_size_bytes` (Histogram) _optional but recommended_
  - **Labels:** `method`, `route`

## E.2.2 Database

- **Name:** `db_query_duration_ms` (Histogram)
  - **Labels (required):** `operation` (e.g., `select|insert|update|delete`), `table`
  - **Buckets (mandated, in ms):** `5, 10, 25, 50, 100, 200, 400, 600, 1000, 2000`
  - **Unit note:** Expose in **seconds** if library requires; CI normalizes to ms for thresholds.

- **Name:** `db_connections` (Gauge)
  - **Labels:** `state` (e.g., `active|idle`)

## E.2.3 Frontend RUM

- **Name:** `frontend_lcp_ms` (Gauge)
  - **Labels (required):** `route`, `device` (`mobile|desktop`), `country` (2-letter, optional SLO cut)
  - **Aggregation requirement:** provide **p75** per route; CI derives from raw samples if exported as summary

- **Name:** `frontend_errors_total` (Counter)
  - **Labels:** `route`, `type` (`js|xhr|promise|console`)

## E.2.4 Process/Runtime (baseline)

- `process_cpu_seconds_total` (Counter)
- `process_resident_memory_bytes` (Gauge)
- `nodejs_eventloop_lag_seconds` or equivalent for runtime

---

# E.3 Exposition Format (Prometheus text)

Sample (HTTP):

```
# HELP http_request_duration_seconds HTTP request latency histogram
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{method="GET",route="/api/v1/sessions/{id}",status_code="200",le="0.05"} 12
http_request_duration_seconds_bucket{method="GET",route="/api/v1/sessions/{id}",status_code="200",le="0.1"} 34
...
http_request_duration_seconds_sum{method="GET",route="/api/v1/sessions/{id}",status_code="200"} 4.21
http_request_duration_seconds_count{method="GET",route="/api/v1/sessions/{id}",status_code="200"} 120
```

Sample (DB):

```
# TYPE db_query_duration_ms histogram
db_query_duration_ms_bucket{operation="select",table="sessions",le="50"} 105
db_query_duration_ms_bucket{operation="select",table="sessions",le="100"} 300
db_query_duration_ms_sum{operation="select",table="sessions"} 12345
db_query_duration_ms_count{operation="select",table="sessions"} 800
```

Sample (RUM):

```
# TYPE frontend_lcp_ms gauge
frontend_lcp_ms{route="/dashboard",device="mobile",country="DE"} 2100
```

---

# E.4 Scrape Targets & Config

Targets must expose `/metrics` on:

- **API pods:** `fitvibe-api:8080/metrics`
- **Frontend collector:** `fitvibe-rum:9090/metrics`

Prometheus scrape job example:

```yaml
scrape_configs:
  - job_name: fitvibe-api
    kubernetes_sd_configs: [{ {} }]
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_label_app]
        regex: fitvibe-api
        action: keep
    metrics_path: /metrics
    scheme: http
    scrape_interval: 15s
  - job_name: fitvibe-rum
    kubernetes_sd_configs: [{ {} }]
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_label_app]
        regex: fitvibe-rum
        action: keep
    metrics_path: /metrics
    scrape_interval: 30s
```

---

# E.5 CI Verification (Contract Tests)

**Step 1 — Reachability & non-empty:**

```bash
curl -fsS $API_METRICS | head -n 5
curl -fsS $RUM_METRICS | head -n 5
```

**Step 2 — Name/type/label checks (Node):**

```js
import fs from 'node:fs';
import {{ parseTextFormat }} from 'prom-text-parser';
const api = parseTextFormat(fs.readFileSync('api.metrics','utf8'));

function assertMetric(name, type){{
  const m = api.find(x => x.name===name);
  if(!m || m.type!==type) throw new Error(`Missing or wrong type: ${{name}}`);
  return m;
}}
const http = assertMetric('http_request_duration_seconds','histogram');
['method','route','status_code'].forEach(l=>{{
  if(!http.series.some(s=>Object.keys(s.labels).includes(l))) throw new Error(`Missing label ${{l}}`);
}});
```

**Step 3 — Bucket policy checks:**

```js
const requiredBuckets = [0.05, 0.1, 0.2, 0.3, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 5].map(String);
const getBuckets = (m) =>
  [...new Set(m.series.filter((s) => "le" in s.labels).map((s) => s.labels.le))].sort(
    (a, b) => parseFloat(a) - parseFloat(b),
  );
const buckets = getBuckets(http);
if (JSON.stringify(buckets) !== JSON.stringify(requiredBuckets))
  throw new Error("HTTP buckets mismatch");
```

**Step 4 — Example series present (smoke routes):**

```js
const hasRoute200 = http.series.some(
  (s) => s.labels.route === "/api/v1/sessions/{id}" && s.labels.status_code === "200",
);
if (!hasRoute200) throw new Error("No 200 /sessions series found");
```

**Step 5 — RUM presence & sample sanity:**

```js
const rum = parseTextFormat(fs.readFileSync("rum.metrics", "utf8")).find(
  (x) => x.name === "frontend_lcp_ms",
);
if (!rum) throw new Error("Missing frontend_lcp_ms");
const ok = rum.series.some((s) => s.labels.route === "/dashboard" && Number(s.value) > 0);
if (!ok) throw new Error("No positive LCP sample");
```

**Exit non‑zero on any failure** to block the pipeline.

---

# E.6 PromQL Checks (used in CI and dashboards)

- **HTTP p95 (per route):**
  ```promql
  histogram_quantile(0.95, sum by (le, route) (rate(http_request_duration_seconds_bucket[5m])))
  ```
- **DB p95 (by table):**
  ```promql
  histogram_quantile(0.95, sum by (le, table) (rate(db_query_duration_ms_bucket[5m])))
  ```
- **RUM LCP p75 (per route, device):**
  ```promql
  quantile_over_time(0.75, frontend_lcp_ms{{route="/dashboard",device="mobile"}}[1h])
  ```

**Budgets (gates):**

- API p95 per group (auth ≤200ms, CRUD ≤300ms, feed ≤400ms, analytics ≤600ms).
- RUM LCP p75 < 2500ms for tracked routes on mobile.

---

# E.7 Alerting Rules (SLO & Budget)

```yaml
groups:
  - name: fitvibe-slo
    rules:
      - alert: APIP95LatencyHigh
        expr: histogram_quantile(0.95, sum by (le) (rate(http_request_duration_seconds_bucket{{route=~"/api/v1/(auth|crud|feed|analytics).*"}}[5m]))) > 0.6
        for: 15m
        labels: { { severity: warning } }
        annotations:
          summary: "API p95 above budget"
      - alert: DBQuerySlow
        expr: histogram_quantile(0.95, sum by (le, table) (rate(db_query_duration_ms_bucket[5m]))) > 600
        for: 15m
        labels: { { severity: warning } }
      - alert: RUM_LCP_Degradation
        expr: quantile_over_time(0.75, frontend_lcp_ms[30m]) > 2500
        for: 30m
        labels: { { severity: warning } }
```

---

# E.8 Evidence & Artifacts (per pipeline)

- `reports/metrics/api.metrics` & `reports/metrics/rum.metrics` (raw scrape)
- `reports/metrics/contract.json` (pass/fail log with reasons)
- Dashboard snapshot PNG/JSON (optional)
- CI summary with PromQL checks and thresholds

---

# E.9 Versioning & Change Control

- Any change to metric **names, labels, or buckets** requires:
  1. Update of this appendix and a minor version bump.
  2. CI contract test update in the same PR.
  3. Dashboard & alert rule revision if matching.

- Deprecations: keep legacy metric exported for **one minor** with `deprecated="true"` label.

---

# E.10 Checklist (Quick)

- [ ] `/metrics` reachable (API & RUM)
- [ ] `http_request_duration_seconds` histogram present with **required labels** and **mandated buckets**
- [ ] `http_requests_total` present
- [ ] `db_query_duration_ms` histogram present with **required labels** and **mandated buckets**
- [ ] `frontend_lcp_ms` present with **route** & **device** labels; samples > 0
- [ ] Example series for smoke routes (200s) present
- [ ] Contract tests passed (CI failed otherwise)
- [ ] Alert rules loaded without errors

---

# E.11 Extended Observability Contract

## E.11.1 Distributed Tracing

### Required Trace Propagation

**Trace ID must propagate:** HTTP → API Handler → DB Query → Queue Job

**Validation (CI):**

```ts
// tests/observability/trace-propagation.test.ts
import { trace } from "@opentelemetry/api";

test("Trace ID propagates to DB spans", async () => {
  const tracer = trace.getTracer("test");

  await tracer.startActiveSpan("test-request", async (span) => {
    const traceId = span.spanContext().traceId;

    // Make API request
    const res = await fetch("/api/v1/sessions", {
      headers: { traceparent: `00-${traceId}-...` },
    });

    // Verify DB span has same trace ID
    const spans = await getExportedSpans();
    const dbSpan = spans.find((s) => s.name === "db.query");

    expect(dbSpan.traceId).toBe(traceId);
    span.end();
  });
});
```

### Sampling Configuration

**Policy:** 10% sampling rate in production

**Validation:**

```ts
test("Sampling rate is 10%", () => {
  const config = require("../../../apps/backend/src/tracing/config");
  expect(config.samplingRate).toBe(0.1);
});
```

### Span Attributes (Required Fields)

**HTTP spans:**

- `http.method`, `http.route`, `http.status_code`, `http.user_agent`

**DB spans:**

- `db.statement` (parameterized, no PII), `db.operation`, `db.name`

**Error spans:**

- `error.type`, `error.message`, `error.stack` (sanitized)

**Contract test:**

```ts
test("API spans include required attributes", async () => {
  await fetch("/api/v1/users/me");
  const spans = await getExportedSpans();
  const apiSpan = spans.find((s) => s.name === "GET /api/v1/users/me");

  expect(apiSpan.attributes).toMatchObject({
    "http.method": "GET",
    "http.route": "/api/v1/users/me",
    "http.status_code": 200,
  });
});
```

## E.11.2 Structured Logging

### Log Schema (JSON)

**Required fields:**

```json
{
  "level": "info|warn|error",
  "timestamp": "2025-10-26T10:00:00.000Z",
  "message": "User logged in",
  "trace_id": "abc123...",
  "user_id": "uuid-...", // Optional, only if authenticated
  "context": {
    // Freeform, but no PII
    "route": "/api/v1/auth/login",
    "duration_ms": 145
  }
}
```

### PII Guard (CI)

**Automated scan for PII patterns in logs:**

```js
// tests/observability/log-pii-scan.test.ts
import { spawn } from "child_process";

test("Logs contain no PII", async () => {
  // Run app with log output to file
  const app = spawn("node", ["dist/main.js"], {
    env: { LOG_LEVEL: "debug", LOG_FILE: "reports/app.log" },
  });

  // Trigger test requests
  await fetch("/api/v1/users/me");
  app.kill();

  // Scan logs for PII patterns
  const logs = fs.readFileSync("reports/app.log", "utf8");
  const emailPattern = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
  const phonePattern = /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g;

  expect(logs).not.toMatch(emailPattern);
  expect(logs).not.toMatch(phonePattern);
});
```

### Log Contract Test

```ts
test("All logs are valid JSON with required fields", () => {
  const logs = fs
    .readFileSync("reports/app.log", "utf8")
    .split("\n")
    .filter(Boolean)
    .map(JSON.parse);

  for (const log of logs) {
    expect(log).toHaveProperty("level");
    expect(log).toHaveProperty("timestamp");
    expect(log).toHaveProperty("message");
    expect(["info", "warn", "error", "debug"]).toContain(log.level);
  }
});
```

## E.11.3 Alert Rule Validation

### Syntax Check (CI)

**Tool:** `promtool` (Prometheus command-line tool)

```yaml
# .github/workflows/ci.yml (in observability job)
- name: Validate Prometheus alert rules
  run: |
    curl -LO https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz
    tar xvfz prometheus-*.tar.gz
    ./prometheus-*/promtool check rules monitoring/alerts/*.yml
```

# Appendix F — DR Drill Runbook (extract)

# F.1 Objectives & Success Criteria

**Purpose.** Validate that FitVibe can recover from a catastrophic failure **within policy**, and that privacy obligations (**erasure-replay**) are satisfied for data subject deletions since the backup snapshot.

**Success criteria (hard gates):**

- **RPO ≤ 24h** — data currency of restored environment relative to drill start.
- **RTO ≤ 4h** — time from _drill kickoff_ to **healthy app** in staging-DR.
- **Delete propagation ≤ 14 days** — all records present in `erasure_ledger` since the backup timestamp are **absent** after replay.
- Evidence bundle is complete, signed by required approvers, and archived.

---

# F.2 RACI & Participants

| Activity             | DevOps | DBA | Privacy Officer | QA Lead | Security | Product Owner |
| -------------------- | ------ | --- | --------------- | ------- | -------- | ------------- |
| Plan & kickoff       | R      | C   | C               | C       | I        | I             |
| Select backups       | R      | A   | I               | I       | I        | I             |
| Restore DB & storage | A      | R   | I               | I       | I        | I             |
| App/bootstrap config | R      | C   | I               | I       | I        | I             |
| Health checks        | R      | C   | I               | A       | I        | I             |
| Erasure-replay       | C      | R   | A               | C       | I        | I             |
| Evidence bundle      | R      | C   | A               | A       | I        | I             |
| Sign-off             | A      | C   | A               | A       | I        | A             |

**R = Responsible, A = Accountable, C = Consulted, I = Informed**

---

# F.3 Preconditions & Controls

- Staging-DR environment exists (isolated VPC/namespace) with:
  - Sufficient compute/storage quotas
  - Access to secrets via **Vault**/**KMS**
  - **Read-only** production access disabled (except for fetching backups)
- **Backups** available:
  - **Database**: nightly logical dumps + weekly physical snapshots
  - **Object storage**: versioned buckets with lifecycle policy
  - **Configs**: encrypted snapshots (in Git and secure secrets store)
- **Erasure ledger** (`compliance.erasure_ledger`) captures deletions with `{subject_id, domain, deleted_at, scope}`
- Tooling installed: `psql`, `pg_restore`, `aws` (or cloud-cli), `jq`, `sha256sum`, `k6` (optional smoke), `kubectl`/`helm`
- Time sync: use UTC for all timestamps

---

# F.4 Data Classification & Anonymization Policy

- **No production PII** is copied into developer-accessible namespaces.
- Restored staging-DR uses **synthetic** users for health checks.
- If prod-like payloads are needed for perf smoke, apply **anonymization transforms** (hash emails, null phone, mask names).
- Access to staging-DR is scoped to drill participants; audit logs enabled.

---

# F.5 Backup Selection

1. List latest successful DB backups:
   ```bash
   aws s3 ls s3://fitvibe-backups/db/ --recursive | tail -n 20
   ```
2. Choose the most recent backup **≤24h** old relative to kickoff.
3. Record: `BACKUP_DB_URI`, backup `created_at`, size, checksum.
4. Select corresponding **object storage** snapshot prefix (same date).

---

# F.6 Drill Timeline & Measurements

- **t0 (Kickoff UTC):** announce start in #ops-dr channel.
- **t1 (Restore start):** when DB restore begins.
- **t2 (Restore end):** DB ready for read/write tests.
- **t3 (App healthy):** all health checks/smokes pass in staging-DR.
- **RTO = t3 - t0**, **RPO = now - backup.created_at**.

Capture timestamps with a shared script (see F.14).

---

# F.7 Environment Provisioning (Staging-DR)

```bash
kubectl create ns staging-dr || true
helm upgrade --install fitvibe-dr charts/fitvibe   --namespace staging-dr   -f charts/values-dr.yaml   --set image.tag=DR-SNAPSHOT   --set env=staging-dr
```

- Inject app secrets via Vault/KMS references (no plain-text secrets).
- Disable **external analytics** and notification webhooks.

---

# F.8 Database Restore Procedure

> Assumes **PostgreSQL** with logical dump (`.dump` or `.sql`).

1. **Provision fresh DB** (managed PG or container).
2. **Restore:**
   ```bash
   export PGPASSWORD=$PG_RESTORE_PASSWORD
   time pg_restore --no-owner --no-acl      --dbname=$PGDATABASE --host=$PGHOST --username=$PGUSER      /backups/fitvibe-YYYYMMDD.dump
   ```
3. **Schema guard:** verify required migrations applied:
   ```bash
   psql "$PGURL" -c "select version from schema_version order by applied_at desc limit 1;"
   ```
4. **Integrity checks:**
   - Row counts for critical tables vs manifest
   - Index presence (GIN on `exercises.tags`, composite indexes on `sessions`)
   ```bash
   psql "$PGURL" -f tests/db/contracts/assert_indexes.sql
   ```

---

# F.9 Object Storage Restore

Restore versioned assets (avatars/exports) to **dr-bucket** with a readonly policy:

```bash
aws s3 sync s3://fitvibe-objects/ s3://fitvibe-objects-dr/   --delete --exact-timestamps --storage-class STANDARD-IA
```

- Disable any public ACLs.
- Validate count & checksums against manifest.

---

# F.10 Application Bootstrap & Health Checks

1. Apply config map and secret refs; roll deployment:
   ```bash
   kubectl rollout restart deploy -n staging-dr fitvibe-web fitvibe-api
   kubectl -n staging-dr wait deploy/fitvibe-api --for=condition=Available=True --timeout=600s
   ```
2. **Smoke tests**:
   - `/healthz` → `200`
   - Register→Verify (fake mailer)→Login→Plan→Complete→Dashboard (Playwright/k6 smoke)
3. **Security headers** present (HSTS, CSP, cookies).

---

# F.11 Erasure-Replay Procedure (GDPR Delete Propagation)

**Goal:** ensure subjects deleted **after** the backup time are also **deleted** in staging-DR.

1. **Identify window:** `backup_ts = backup.created_at`.
2. **Fetch ledger slice:**
   ```sql
   select subject_id, domain, deleted_at
   from compliance.erasure_ledger
   where deleted_at >= :backup_ts
   order by deleted_at asc;
   ```
3. **Replay deletions (pseudo-SQL):**

   ```sql
   -- Example for sessions
   delete from sessions where user_id in (:subjects);
   delete from session_exercises where session_id not in (select id from sessions);
   -- Example for profiles
   update users set deleted_at = now(), email = null, alias = concat('deleted_', id)
   where id in (:subjects);
   ```

   - For object storage, remove PII-related keys:
     ```bash
     aws s3 rm s3://fitvibe-objects-dr/ --recursive --exclude "*" --include "users/*/{subjects}/*"
     ```

4. **Verify absence:** for each subject in the ledger slice:
   - No rows in `users` except anonymized stub.
   - No PII-bearing records in domain tables.
   - No assets under the user prefix in object storage.
5. **Record totals:** `N_subjects`, tables touched, objects removed.

**Gate:** all subjects in ledger slice absent/anonymized → **Pass**.

---

# F.12 Consistency, Compliance & Observability Checks

- **Referential integrity:** no orphans (`session_exercises` → `sessions`).
- **Metrics contract** exposed at `/metrics` (HTTP/DB histograms).
- **Audit trails:** operations logged; admin actions attributed.
- **A11y/Perf quick checks** (optional): Lighthouse budget sanity.

---

# F.13 Acceptance & Sign‑Off

- **RTO (≤4h):** measured t3−t0 → Pass/Fail
- **RPO (≤24h):** now−backup.created_at → Pass/Fail
- **Erasure-propagation (≤14d):** verified with query suite → Pass/Fail
- **Security headers present:** Pass/Fail

**Approvals required:** DevOps, Privacy Officer, QA Lead, Product Owner.

---

# F.14 Evidence Bundle Manifest (what to archive)

```
/reports/dr/YYYY-MM-DD/
├─ 00_metadata.json                 # backup URIs, checksums, env, team
├─ 01_timeline.json                 # t0..t3 UTC timestamps, RTO/RPO
├─ 02_db_restore.log                # pg_restore transcript
├─ 03_db_contracts.html             # index/FK/schema checks
├─ 04_object_storage_sync.log
├─ 05_health_checks.json            # healthz, smoke results
├─ 06_security_headers.html         # ZAP/headers snapshot
├─ 07_erasure_ledger_slice.csv
├─ 08_erasure_replay.sql            # exact statements executed
├─ 09_erasure_verification.csv      # counts per subject/table
├─ 10_summary.md                    # result, issues, follow-ups
└─ signatures/
   ├─ privacy_officer.sig
   ├─ qa_lead.sig
   └─ devops_lead.sig
```

Archive in WORM location with 1-year retention.

---

# F.15 Automation Scripts (snippets)

**Timeline capture:**

```bash
jq -n --arg t0 "$(date -u +%FT%TZ)" '{{"t0":$t0}}' > /reports/dr/01_timeline.json
# ... add t1..t3 afterward using jq --slurpfile
```

**RPO/RTO calc (Node):**

```js
const meta = require("./00_metadata.json");
const tl = require("./01_timeline.json");
const rpoHours = (Date.parse(tl.t0) - Date.parse(meta.backup_created_at)) / 36e5;
const rtoHours = (Date.parse(tl.t3) - Date.parse(tl.t0)) / 36e5;
console.log({ rpoHours, rtoHours });
process.exit(rpoHours <= 24 && rtoHours <= 4 ? 0 : 1);
```

**Erasure verification (SQL skeleton):**

```sql
-- confirm no PII for subjects
select subject_id, count(*) as remaining
from (
  select user_id as subject_id from sessions where user_id in (:subjects)
  union all
  select id as subject_id from users where id in (:subjects) and email is not null
) q
group by subject_id;
```

---

# F.16 Rollback & Lessons Learned

- If any gate fails, keep staging-DR up for analysis; file issues with **labels:** `dr-failure`, `rto-breach`, `rpo-breach`, `erasure-gap`.
- Run a targeted **re-drill** within 10 business days after remediation.
- Add missing automation to CI (e.g., daily ledger delta check, restore smoke).

---

# F.17 Risks & Mitigations (DR-specific)

| Risk               | Likelihood | Impact | Mitigation                                     |
| ------------------ | ---------- | ------ | ---------------------------------------------- |
| Backup corrupted   | Low        | High   | Checksums + restore test of last N backups     |
| Ledger gaps        | Low        | High   | Transactional writes; alert on failed writes   |
| Secret mismatch    | Medium     | Medium | Vault version pinning; preflight secret diff   |
| Index drift        | Medium     | Medium | DB contract tests in CI; assert post-restore   |
| Object restore lag | Medium     | Low    | Parallel sync; manifest; checksum verification |
| Human error        | Medium     | Medium | Pair ops; runbook checklists; dry-runs         |

---

# F.18 Checklists (Quick)

**Kickoff**

- [ ] t0 recorded
- [ ] Backup ≤24h chosen; checksum verified
- [ ] Scope & roles confirmed

**Restore**

- [ ] DB restored; schema/migrations verified
- [ ] Objects restored; counts & checksums match

**Health**

- [ ] App healthy in staging-DR (t3 recorded)
- [ ] Headers/CSP verified

**Erasure**

- [ ] Ledger slice exported
- [ ] Replay executed
- [ ] Verification shows 0 PII remnants

**Wrap-up**

- [ ] Evidence bundle archived
- [ ] Signatures collected
- [ ] Postmortem scheduled

---
