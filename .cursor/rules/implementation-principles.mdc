---
description: "Core implementation principles and 'When Writing Code' guidelines - non-negotiable rules for all implementations"
globs: ["apps/**"]
alwaysApply: true
ruleType: "always"
tags: ["implementation-principles", "code-quality", "best-practices", "critical"]
---

# Implementation Principles

**CRITICAL**: These principles are non-negotiable and must be followed in all implementations.

1. **Never use placeholders or fake data** - Implement full functionality, never use `TODO`, `FIXME`, `placeholder`, `mock`, `fake`, `dummy`, or `stub` in production code
2. **Never reduce code quality** - Don't simplify at the expense of quality, maintainability, or correctness. Always include proper error handling, validation, and type safety
3. **Always use global settings** - Never hardcode URLs, ports, timeouts, limits, or magic numbers. All configuration must come from environment variables or centralized config files
4. **Always use i18n for text** - All user-facing text (labels, buttons, errors, placeholders, messages) must come from i18n translation files, never hardcoded
5. **Complete error handling** - Use `HttpError` utility with specific error codes and messages. Never use generic errors or swallow exceptions
6. **Type safety** - Strict TypeScript compliance, no `any` types in public surfaces, proper type definitions for all APIs
7. **Comprehensive testing** - Write tests for all new functionality (unit + integration), maintain ≥80% coverage, test happy paths, errors, and edge cases
8. **Proper architecture** - Follow Controller → Service → Repository pattern, keep controllers thin, business logic in services, data access in repositories
9. **Security first** - Validate all input, use parameterized queries, implement proper auth/authz, follow privacy-by-default
10. **Accessibility by default** - All UI components must be accessible (ARIA labels, keyboard navigation, WCAG 2.1 AA compliant)

See `docs/6.Implementation/implementation_principles.md` for detailed examples and guidelines.

## When Writing Code

1. **Always** use TypeScript strict mode - no `any` types in public surfaces
2. **Always** validate input with Zod schemas before processing
3. **Always** use adapter pattern for external services (email, storage, antivirus)
4. **Always** include error handling and appropriate HTTP status codes
5. **Always** write tests for new functionality (unit + integration)
6. **Always** update documentation when changing behavior
7. **Always** ensure accessibility (ARIA labels, keyboard navigation)
8. **Always** consider security implications (rate limiting, input validation, SQL injection prevention)
9. **Always** use UTC for timestamps
10. **Always** use UUIDv7/ULID for new identifiers
11. **Always** use `.js` extensions in import statements (ESM)
12. **Always** use `asyncHandler` wrapper for Express route handlers
13. **Always** implement idempotency for state-changing operations
14. **Always** use transactions for multi-step database operations
15. **Always** use React Query for server state management in frontend
16. **Always** use i18n for all user-facing text (never hardcode strings)
17. **Always** use configuration from `env.ts` or config files (never hardcode values)
18. **Always** implement complete functionality (never use placeholders or simplified versions)

## Quick Reference: Most Common Tasks

Based on chat history analysis, these are the most frequently requested tasks:

1. **Create API endpoints** (83 requests) - See "Backend Route Handler Pattern" in `implementation-patterns.mdc`
2. **Create database migrations** (42 requests) - See "Database Migration Pattern" in `implementation-patterns.mdc`
3. **Create/update tests** (40 requests) - See "Testing Patterns" in `implementation-patterns.mdc`
4. **Update existing code** (32 requests) - Follow existing patterns, maintain consistency
5. **Create React components** (14 requests) - See "Frontend Component Pattern" in `implementation-patterns.mdc`
