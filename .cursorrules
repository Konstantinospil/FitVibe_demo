# FitVibe V2 - Cursor AI Rules

## Project Overview
FitVibe is a holistic fitness platform where users can plan, log, share, and track training sessions across six elemental vibes (Strength/Earth, Agility/Air, Endurance/Water, Explosivity/Fire, Intelligence/Shadow, Regeneration/Aether). The platform is built as a monorepo using PNPM workspaces with a modular, scalable architecture.

## Repository Structure
- `app/backend/` - Express/TypeScript REST API
- `app/frontend/` - React SPA built with Vite
- `docs/` - Product, design, and governance documentation
- `infra/` - Infrastructure, Docker, Kubernetes configs
- `packages/` - Shared tooling, lint rules, TypeScript config

## Technology Stack

### Backend
- Node.js 20 LTS
- Express.js
- TypeScript (strict mode, no `any` in public surfaces)
- Knex.js (SQL query builder)
- PostgreSQL (â‰¥14, target 16-18)
- Zod (validation)
- jose (JWT)
- nodemailer (email)
- rate-limiter-flexible

### Frontend
- React 18
- Vite
- TypeScript (strict mode)
- React Router
- i18n library

### Infrastructure
- Docker & Docker Compose
- Kubernetes
- NGINX (reverse proxy)
- Observability stack (Prometheus, Grafana, Loki, Tempo)

## Coding Standards

### TypeScript
- **Strict mode enabled** - no `any` types in public surfaces
- Use TypeScript project references for incremental builds
- Prefer type inference where possible, but be explicit for public APIs
- Use interfaces for object shapes, types for unions/intersections

### Code Organization
- **Backend**: Folder-by-module structure (`/modules/<domain>`), co-locating routes, services, schemas, tests
- **Frontend**: Feature-sliced architecture
- Disallow cross-layer imports that bypass public APIs (enforced via ESLint boundaries)

### Formatting & Linting
- ESLint (recommended + security plugins)
- Prettier for code formatting
- Run `pnpm lint` and `pnpm lint --fix` before committing

### API Conventions
- **REST over HTTPS**, JSON bodies
- **camelCase** in JSON request/response bodies
- **snake_case** in database columns
- UTC timestamps, RFC 3339 format in APIs
- State-changing endpoints accept `Idempotency-Key` header (store for 24h)
- Use UUIDv7/ULID for identifiers (immutable)

### Database
- PostgreSQL with snake_case naming
- Use Knex.js for migrations and queries
- Partition large tables for performance
- Use materialized views for analytics
- GIN/JSONB indexing for semi-structured data

## Security & Privacy

### Security First
- Never commit secrets, API keys, or personal data
- All external calls (email) must be adapterized and mockable for tests
- Follow OWASP Top 10 guidelines
- Implement rate limiting on all public endpoints
- Use RS256 for JWT signing
- 2FA support (TOTP)
- Brute-force protection

### Privacy & GDPR
- **Privacy-by-default**: Private-by-default content, explicit consent for public sharing
- GDPR compliant: Privacy-by-default settings and user-controlled data management
- Data minimization principles
- Support for Data Subject Rights (DSR): access, rectification, deletion, portability

## Accessibility
- **WCAG 2.1 AA compliant** interface
- UI components accessible by default (labels/ARIA)
- Test with Lighthouse for accessibility metrics

## Testing

### Testing Standards
- Unit and integration tests live under `tests/` and per-workspace `apps/*/tests`
- Use test doubles (mocks, stubs, spies, fakes) for external services
- Do not hit live third-party APIs in tests
- Use FakeClock for time-dependent code testing
- Use PRNG for deterministic test data generation
- Avoid flaky tests - ensure deterministic behavior

### Testing Tools
- **Jest** for backend unit/integration tests
- **Vitest** for frontend unit tests
- **Playwright** for E2E tests
- **k6** for performance/load testing
- **Supertest** for HTTP assertion in backend tests

## Documentation

### When to Update Documentation
- Product or UX changes: update PRD (`docs/1.Product_Requirements/`)
- Technical changes: update TDD (`docs/2.Technical_Design_Document/`)
And
- Architecture decisions: add or update ADR in `docs/2.Technical_Design_Document/2.f.Architectural_Decision_Documentation/`
- Infrastructure updates: document in `infra/README.md`

### Documentation Standards
- Use conventional commit messages (`feat:`, `fix:`, `docs:`, `chore:`)
- Link changes to relevant PRD/TDD sections
- Update RTM (Requirements Traceability Matrix) when requirements change

## Development Workflow

### Branching
- Branch from `develop` for new features
- Use descriptive branch names: `feat/session-planner`, `fix/auth-refresh`, `docs/i18n-guidelines`
- Sign commits if GPG key is configured

### Quality Gates
Before submitting PR, run:
```bash
pnpm lint
pnpm test
pnpm typecheck
```

### Pull Request Requirements
- Summary of change and motivation
- Screenshots/terminal output for UX changes
- Links to updated PRD/TDD sections
- Checklist covering tests, documentation, and security considerations

## Key Domain Concepts

### Vibes & Elements
- **Strength** (Earth): Lifting, strongman, body building
- **Agility** (Air): Juggling, climbing, bouldering, gymnastics, parkour
- **Endurance** (Water): Running, hiking, cycling, rowing, jump rope
- **Explosivity** (Fire): Sprints, jumps, throws
- **Intelligence** (Shadow): Chess, shooting, sailing
- **Regeneration** (Aether): Yoga, stretching, fasting

### Roles
- `anonymous` - unauthenticated users
- `user` - authenticated users
- `admin` - administrative users

### Key Terms
- **Session**: A training session that can be planned, logged, and shared
- **Exercise Library**: Global exercise library with comparable metrics
- **Public Link**: Shareable link with private visibility model
- **Idempotency**: Operations that can be applied multiple times without changing result beyond initial application

## Observability
- Use OpenTelemetry (OTEL) for traces
- Structured JSON logs to Loki or filebeat-compatible sink
- Prometheus metrics for SLI/SLO monitoring
- Grafana dashboards for visualization

## When Writing Code

1. **Always** use TypeScript strict mode - no `any` types
2. **Always** validate input with Zod schemas
3. **Always** use adapter pattern for external services (email, etc.)
4. **Always** include error handling and appropriate HTTP status codes
5. **Always** write tests for new functionality
6. **Always** update documentation when changing behavior
7. **Always** ensure accessibility (ARIA labels, keyboard navigation)
8. **Always** consider security implications (rate limiting, input validation, SQL injection prevention)
9. **Always** use UTC for timestamps
10. **Always** use UUIDv7/ULID for new identifiers

## Common Patterns

### Backend Route Handler
```typescript
// Validate input with Zod
const schema = z.object({ ... });
const validated = schema.parse(req.body);

// Use adapterized services
const result = await emailAdapter.send(...);

// Return appropriate status codes
res.status(201).json({ ... });
```

### Frontend Component
```typescript
// Accessible by default
<button aria-label="Submit form">
  Submit
</button>

// Use i18n for text
const t = useTranslation();
return <p>{t('common.welcome')}</p>;
```

## References
- PRD: `docs/1.Product_Requirements/1.Product_Requirements_Document.md`
- TDD: `docs/2.Technical_Design_Document/`
- ADRs: `docs/2.Technical_Design_Document/2.f.Architectural_Decision_Documentation/`
- Glossary: `docs/0.Glossary.md`
- Contributing: `CONTRIBUTING.md`


