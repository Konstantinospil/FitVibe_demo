# FitVibe V2 - Cursor AI Rules

## Project Overview
FitVibe is a holistic fitness platform where users can plan, log, share, and track training sessions across six elemental vibes (Strength/Earth, Agility/Air, Endurance/Water, Explosivity/Fire, Intelligence/Shadow, Regeneration/Aether). The platform is built as a monorepo using PNPM workspaces with Turborepo for task orchestration and a modular, scalable architecture.

## Repository Structure
- `apps/backend/` - Express/TypeScript REST API with modular domain architecture
- `apps/frontend/` - React 18 SPA built with Vite
- `docs/` - Product, design, and governance documentation
- `infra/` - Infrastructure, Docker, Kubernetes configs
- `packages/` - Shared tooling, lint rules, TypeScript config, i18n
- `tests/` - E2E, integration, performance, and QA test suites
- `scripts/` - Utility scripts for development and maintenance

## Technology Stack

### Backend (`apps/backend/`)
- **Runtime**: Node.js 20 LTS (≥18.19 required)
- **Framework**: Express.js
- **Language**: TypeScript (strict mode, no `any` in public surfaces)
- **Database**: PostgreSQL (≥14, target 16-18) with Knex.js query builder
- **Validation**: Zod schemas for all input validation
- **Auth**: jose (JWT), @otplib/preset-default (2FA/TOTP)
- **Email**: nodemailer (adapterized for testing)
- **Rate Limiting**: rate-limiter-flexible
- **Caching**: ioredis (Redis), node-cache (in-memory)
- **Queue**: BullMQ for background jobs
- **Observability**: OpenTelemetry, Prometheus (prom-client), Pino (structured logging)
- **File Processing**: Sharp (image processing), ClamAV (antivirus scanning)
- **Testing**: Jest with Supertest, ts-jest, pg-mem

### Frontend (`apps/frontend/`)
- **Framework**: React 18
- **Build Tool**: Vite
- **Language**: TypeScript (strict mode)
- **Routing**: React Router v6
- **State Management**: Zustand (global state), React Query/TanStack Query (server state)
- **i18n**: i18next with react-i18next
- **UI Components**: Custom components in `components/ui/`, Lucide React icons
- **Charts**: Recharts
- **Testing**: Vitest, React Testing Library, @testing-library/user-event
- **E2E**: Playwright (in `tests/frontend/e2e/`)

### Infrastructure
- **Package Manager**: PNPM 9.14.4 (enforced via `packageManager` field)
- **Monorepo**: Turborepo for task orchestration and caching
- **Containerization**: Docker & Docker Compose
- **Orchestration**: Kubernetes
- **Reverse Proxy**: NGINX
- **Observability**: Prometheus, Grafana, Loki, Tempo
- **CI/CD**: GitHub Actions (referenced in workflows)

## Coding Standards

### TypeScript
- **Strict mode enabled** - no `any` types in public surfaces (warn in tests)
- Use TypeScript project references for incremental builds (`tsc -b`)
- Prefer type inference where possible, but be explicit for public APIs
- Use interfaces for object shapes, types for unions/intersections
- Use `type` imports for type-only imports: `import type { ... }`
- Enforce consistent type imports via ESLint rule
- Use `.js` extensions in imports (ESM compatibility)

### Code Organization

#### Backend Module Structure (`apps/backend/src/modules/`)
Each module follows a **folder-by-module** pattern with co-located files:
- `*.routes.ts` - Express route definitions
- `*.controller.ts` - Request/response handlers (thin layer)
- `*.service.ts` - Business logic (domain layer)
- `*.repository.ts` - Data access layer (Knex queries)
- `*.types.ts` - TypeScript type definitions
- `*.schemas.ts` - Zod validation schemas
- `*.middleware.ts` - Module-specific middleware
- `__tests__/` - Unit and integration tests

**Active Modules**:
- `auth` - Authentication, registration, token management, 2FA
- `users` - User profiles, admin operations, avatars, GDPR DSR
- `exercise-types` - Global exercise type catalog (admin-only)
- `exercises` - User exercise records (CRUD)
- `sessions` - Workout session planning, logging, cloning, recurrence
- `plans` - Training plan management
- `points` - Gamification: points, badges, streaks, seasonal events
- `progress` - Analytics, summaries, trends, exports, plan progress
- `feed` - Social feed, bookmarks, reactions, shares, moderation
- `logs` - Audit log streaming and querying (in progress)
- `health` - Health check endpoints
- `system` - System status, read-only mode, maintenance controls
- `admin` - Admin-only operations
- `common` - Shared middleware, utilities, cross-cutting concerns

#### Frontend Structure (`apps/frontend/src/`)
- `components/` - Reusable UI components (with `ui/` subdirectory for base components)
- `pages/` - Page-level components (route handlers)
- `routes/` - Route definitions and protected route wrappers
- `contexts/` - React contexts (AuthContext, ToastContext)
- `hooks/` - Custom React hooks
- `services/` - API client services
- `store/` - Zustand stores
- `utils/` - Utility functions
- `i18n/` - Internationalization configuration and locales
- `styles/` - Global styles

### Formatting & Linting
- **ESLint**: Flat config with TypeScript ESLint, React, React Hooks, JSX A11y, Prettier plugins
- **Prettier**: Enforced via ESLint plugin
  - Print width: 100
  - Semicolons: required
  - Single quotes: false (double quotes)
  - Trailing commas: all
  - Arrow parens: always
- Run `pnpm lint` and `pnpm lint --fix` before committing
- Max warnings: 0 (enforced in CI)

### API Conventions
- **REST over HTTPS**, JSON bodies
- **camelCase** in JSON request/response bodies
- **snake_case** in database columns
- UTC timestamps, RFC 3339 format in APIs
- State-changing endpoints (POST, PUT, PATCH, DELETE) accept `Idempotency-Key` header (store for 24h)
- Use UUIDv7/ULID for identifiers (immutable)
- API versioning: `/api/v1/` prefix
- Error responses: `{ error: string, code: string }` format
- Use `HttpError` utility for consistent error handling

### Database
- PostgreSQL with snake_case naming
- Use Knex.js for migrations and queries
- Migrations in `apps/backend/src/db/migrations/`
- Seeds in `apps/backend/src/db/seeds/`
- Partition large tables for performance
- Use materialized views for analytics
- GIN/JSONB indexing for semi-structured data
- Use transactions for multi-step operations
- Always use parameterized queries (Knex handles this)

## Security & Privacy

### Security First
- Never commit secrets, API keys, or personal data
- All external calls (email, antivirus, storage) must be adapterized and mockable for tests
- Follow OWASP Top 10 guidelines
- Implement rate limiting on all public endpoints
- Use RS256 for JWT signing (not HS256)
- 2FA support (TOTP) via @otplib/preset-default
- Brute-force protection on auth endpoints
- CSRF protection via csrf middleware
- Helmet.js for security headers
- Input validation with Zod on all endpoints
- SQL injection prevention via Knex parameterized queries
- File upload validation (size, MIME type, antivirus scanning)

### Privacy & GDPR
- **Privacy-by-default**: Private-by-default content, explicit consent for public sharing
- GDPR compliant: Privacy-by-default settings and user-controlled data management
- Data minimization principles
- Support for Data Subject Rights (DSR): access, rectification, deletion, portability
- Audit logging for GDPR events (export, deletion)
- 14-day grace period for account deletion

## Accessibility
- **WCAG 2.1 AA compliant** interface
- UI components accessible by default (labels/ARIA)
- Keyboard navigation support for all interactive elements
- Screen reader testing with axe-core
- Test with Lighthouse for accessibility metrics (target: 100% score)
- Use semantic HTML elements
- Proper focus management for modals and dynamic content

## Testing

### Testing Standards
- Unit and integration tests live under `apps/*/tests/` and `tests/` workspace
- Use test doubles (mocks, stubs, spies, fakes) for external services
- Do not hit live third-party APIs in tests
- Use FakeClock for time-dependent code testing
- Use PRNG for deterministic test data generation
- Use deterministic UUIDs in tests
- Avoid flaky tests - ensure deterministic behavior
- Coverage targets: ≥80% repo-wide, ≥90% for critical paths (auth/session/points)

### Testing Tools
- **Backend**: Jest with Supertest for HTTP assertions, ts-jest, pg-mem for in-memory DB
- **Frontend**: Vitest with React Testing Library, @testing-library/user-event
- **E2E**: Playwright across Chromium/WebKit/Firefox
- **Performance**: k6 for load testing
- **Accessibility**: @axe-core/playwright for E2E a11y tests
- **Security**: Custom security checks in `tests/security/`

### Test Structure
- Backend: `apps/backend/src/modules/<module>/__tests__/` for module tests
- Frontend: `apps/frontend/tests/` with mirror structure of `src/`
- E2E: `tests/frontend/e2e/` for Playwright tests
- Integration: `tests/backend/integration/` for cross-module tests
- Performance: `tests/perf/` for k6 scripts

## Documentation

### When to Update Documentation
- Product or UX changes: update PRD (`docs/1.Product_Requirements/`)
- Technical changes: update TDD (`docs/2.Technical_Design_Document/`)
- Architecture decisions: add or update ADR in `docs/2.Technical_Design_Document/2.f.Architectural_Decision_Documentation/`
- Infrastructure updates: document in `infra/README.md`
- Module changes: update `apps/backend/src/modules/README.md`

### Documentation Standards
- Use conventional commit messages (`feat:`, `fix:`, `docs:`, `chore:`, `refactor:`, `test:`)
- Link changes to relevant PRD/TDD sections
- Update RTM (Requirements Traceability Matrix) when requirements change
- Keep README files in each directory up to date

## Development Workflow

### Branching
- Branch from `develop` for new features
- Use descriptive branch names: `feat/session-planner`, `fix/auth-refresh`, `docs/i18n-guidelines`
- Sign commits if GPG key is configured
- Use conventional commits

### Quality Gates
Before submitting PR, run:
```bash
pnpm lint          # ESLint + Prettier
pnpm test          # All test suites
pnpm typecheck     # TypeScript type checking
```

### Pull Request Requirements
- Summary of change and motivation
- Screenshots/terminal output for UX changes
- Links to updated PRD/TDD sections
- Checklist covering tests, documentation, and security considerations
- Ensure all CI checks pass

### Turborepo Tasks
- `pnpm dev` - Start all apps in development mode (parallel, no cache)
- `pnpm build` - Build all apps (with dependency graph)
- `pnpm lint` - Lint all workspaces (no cache)
- `pnpm test` - Run all test suites (no cache)
- `pnpm typecheck` - Type check all workspaces (no cache)

## Key Domain Concepts

### Vibes & Elements
- **Strength** (Earth): Lifting, strongman, body building
- **Agility** (Air): Juggling, climbing, bouldering, gymnastics, parkour
- **Endurance** (Water): Running, hiking, cycling, rowing, jump rope
- **Explosivity** (Fire): Sprints, jumps, throws
- **Intelligence** (Shadow): Chess, shooting, sailing
- **Regeneration** (Aether): Yoga, stretching, fasting

### Roles
- `anonymous` - unauthenticated users
- `user` - authenticated users
- `admin` - administrative users

### Key Terms
- **Session**: A training session that can be planned, logged, and shared
- **Exercise Library**: Global exercise library with comparable metrics
- **Public Link**: Shareable link with private visibility model
- **Idempotency**: Operations that can be applied multiple times without changing result beyond initial application
- **Training Unit**: Coach-assigned training structure with exercises and repeat counts
- **Plan**: Recurring training plan that generates scheduled sessions

## Observability
- Use OpenTelemetry (OTEL) for distributed tracing
- Structured JSON logs via Pino to Loki or filebeat-compatible sink
- Prometheus metrics (prom-client) for SLI/SLO monitoring
- Grafana dashboards for visualization
- Correlation IDs for request tracing

## Implementation Principles

**CRITICAL**: These principles are non-negotiable and must be followed in all implementations.

1. **Never use placeholders or fake data** - Implement full functionality, never use `TODO`, `FIXME`, `placeholder`, `mock`, `fake`, `dummy`, or `stub` in production code
2. **Never reduce code quality** - Don't simplify at the expense of quality, maintainability, or correctness. Always include proper error handling, validation, and type safety
3. **Always use global settings** - Never hardcode URLs, ports, timeouts, limits, or magic numbers. All configuration must come from environment variables or centralized config files
4. **Always use i18n for text** - All user-facing text (labels, buttons, errors, placeholders, messages) must come from i18n translation files, never hardcoded
5. **Complete error handling** - Use `HttpError` utility with specific error codes and messages. Never use generic errors or swallow exceptions
6. **Type safety** - Strict TypeScript compliance, no `any` types in public surfaces, proper type definitions for all APIs
7. **Comprehensive testing** - Write tests for all new functionality (unit + integration), maintain ≥80% coverage, test happy paths, errors, and edge cases
8. **Proper architecture** - Follow Controller → Service → Repository pattern, keep controllers thin, business logic in services, data access in repositories
9. **Security first** - Validate all input, use parameterized queries, implement proper auth/authz, follow privacy-by-default
10. **Accessibility by default** - All UI components must be accessible (ARIA labels, keyboard navigation, WCAG 2.1 AA compliant)

See `docs/6.Implementation/implementation_principles.md` for detailed examples and guidelines.

## When Writing Code

1. **Always** use TypeScript strict mode - no `any` types in public surfaces
2. **Always** validate input with Zod schemas before processing
3. **Always** use adapter pattern for external services (email, storage, antivirus)
4. **Always** include error handling and appropriate HTTP status codes
5. **Always** write tests for new functionality (unit + integration)
6. **Always** update documentation when changing behavior
7. **Always** ensure accessibility (ARIA labels, keyboard navigation)
8. **Always** consider security implications (rate limiting, input validation, SQL injection prevention)
9. **Always** use UTC for timestamps
10. **Always** use UUIDv7/ULID for new identifiers
11. **Always** use `.js` extensions in import statements (ESM)
12. **Always** use `asyncHandler` wrapper for Express route handlers
13. **Always** implement idempotency for state-changing operations
14. **Always** use transactions for multi-step database operations
15. **Always** use React Query for server state management in frontend
16. **Always** use i18n for all user-facing text (never hardcode strings)
17. **Always** use configuration from `env.ts` or config files (never hardcode values)
18. **Always** implement complete functionality (never use placeholders or simplified versions)

## Quick Reference: Most Common Tasks

Based on chat history analysis, these are the most frequently requested tasks:

1. **Create API endpoints** (83 requests) - See "Backend Route Handler Pattern" below
2. **Create database migrations** (42 requests) - See "Database Migration Pattern" below
3. **Create/update tests** (40 requests) - See "Testing Patterns" below
4. **Update existing code** (32 requests) - Follow existing patterns, maintain consistency
5. **Create React components** (14 requests) - See "Frontend Component Pattern" below

## Common Patterns

### Backend Route Handler Pattern
```typescript
// modules/example/example.controller.ts
import type { Request, Response } from "express";
import { asyncHandler } from "../../utils/async-handler.js";
import { HttpError } from "../../utils/http.js";
import { createExampleSchema } from "./example.schemas.js";
import { createExample } from "./example.service.js";
import { getIdempotencyKey, getRouteTemplate } from "../common/idempotency.helpers.js";
import { resolveIdempotency, persistIdempotencyResult } from "../common/idempotency.service.js";

export async function createExampleHandler(req: Request, res: Response): Promise<void> {
  const userId = req.user?.sub;
  if (!userId) {
    throw new HttpError(401, "E.UNAUTHENTICATED", "UNAUTHENTICATED");
  }

  // Validate input
  const validated = createExampleSchema.parse(req.body);

  // Idempotency support
  const idempotencyKey = getIdempotencyKey(req);
  if (idempotencyKey) {
    const route = getRouteTemplate(req);
    const resolution = await resolveIdempotency(
      { userId, method: req.method, route, key: idempotencyKey },
      validated,
    );

    if (resolution.type === "replay") {
      res.set("Idempotency-Key", idempotencyKey);
      res.set("Idempotent-Replayed", "true");
      res.status(resolution.status).json(resolution.body);
      return;
    }

    const result = await createExample(validated, userId);

    if (resolution.recordId) {
      await persistIdempotencyResult(resolution.recordId, 201, result);
    }

    res.set("Idempotency-Key", idempotencyKey);
    res.status(201).json(result);
    return;
  }

  const result = await createExample(validated, userId);
  res.status(201).json(result);
}
```

### Backend Service Pattern
```typescript
// modules/example/example.service.ts
import { exampleRepository } from "./example.repository.js";
import type { CreateExampleDTO } from "./example.types.js";
import { HttpError } from "../../utils/http.js";

export async function createExample(data: CreateExampleDTO, userId: string) {
  // Business logic validation
  if (data.name.length < 3) {
    throw new HttpError(400, "E.INVALID_INPUT", "Name must be at least 3 characters");
  }

  // Call repository
  return await exampleRepository.create({ ...data, user_id: userId });
}
```

### Backend Repository Pattern
```typescript
// modules/example/example.repository.ts
import db from "../../db/index.js";
import type { ExampleRow, CreateExampleInput } from "./example.types.js";

export async function createExample(input: CreateExampleInput): Promise<ExampleRow> {
  const [row] = await db("examples")
    .insert(input)
    .returning("*");
  return row;
}

export async function findExampleById(id: string): Promise<ExampleRow | undefined> {
  return await db("examples").where({ id }).first();
}
```

### Frontend Component Pattern
```typescript
// components/ExampleComponent.tsx
import React from "react";
import { useTranslation } from "react-i18next";
import { useQuery } from "@tanstack/react-query";
import { Button } from "./ui/Button";

export const ExampleComponent: React.FC = () => {
  const { t } = useTranslation("common");
  const { data, isLoading } = useQuery({
    queryKey: ["example"],
    queryFn: () => fetchExample(),
  });

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <h1>{t("example.title")}</h1>
      <Button aria-label={t("example.submit")}>
        {t("example.submit")}
      </Button>
    </div>
  );
};
```

### Frontend API Service Pattern
```typescript
// services/api.ts
import axios from "axios";
import { getAuthToken } from "../utils/jwt";

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
});

apiClient.interceptors.request.use((config) => {
  const token = getAuthToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const exampleApi = {
  create: (data: CreateExampleDTO) => apiClient.post("/api/v1/examples", data),
  list: () => apiClient.get("/api/v1/examples"),
};
```

### Database Migration Pattern
```typescript
// apps/backend/src/db/migrations/YYYYMMDDHHMM_description.ts
import type { Knex } from "knex";

export async function up(knex: Knex): Promise<void> {
  await knex.schema.createTable("table_name", (table) => {
    table.uuid("id").primary().defaultTo(knex.raw("gen_random_uuid()"));
    table.string("name").notNullable();
    table.uuid("user_id").notNullable().references("id").inTable("users").onDelete("CASCADE");
    table.timestamp("created_at").notNullable().defaultTo(knex.fn.now());
    table.timestamp("updated_at").notNullable().defaultTo(knex.fn.now());

    // Indexes
    table.index("user_id");
    table.index("created_at");

    // Constraints
    table.unique(["user_id", "name"]);
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTableIfExists("table_name");
}
```

**Migration Best Practices:**
- Use descriptive names: `YYYYMMDDHHMM_verb_noun.ts` (e.g., `202501201430_create_user_profiles.ts`)
- Always implement both `up()` and `down()` functions
- Use transactions for data migrations
- Add indexes for foreign keys and frequently queried columns
- Use `snake_case` for table and column names
- Use UUIDs with `gen_random_uuid()` for primary keys
- Add `created_at` and `updated_at` timestamps
- Use foreign key constraints with appropriate `onDelete` actions
- Test migrations in both directions (up and down)

### Testing Patterns

#### Backend Test Pattern (Jest)
```typescript
// modules/example/__tests__/example.service.test.ts
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import { createExample } from "../example.service.js";
import { exampleRepository } from "../example.repository.js";
import { HttpError } from "../../utils/http.js";

jest.mock("../example.repository.js");

describe("createExample", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should create example with valid data", async () => {
    const mockData = { name: "Test", userId: "user-123" };
    const mockResult = { id: "example-123", ...mockData };

    jest.mocked(exampleRepository.create).mockResolvedValue(mockResult);

    const result = await createExample(mockData, "user-123");

    expect(result).toEqual(mockResult);
    expect(exampleRepository.create).toHaveBeenCalledWith(
      expect.objectContaining({ name: "Test", user_id: "user-123" })
    );
  });

  it("should throw HttpError for invalid input", async () => {
    await expect(createExample({ name: "ab" }, "user-123")).rejects.toThrow(HttpError);
  });
});
```

#### Frontend Test Pattern (Vitest)
```typescript
// components/__tests__/ExampleComponent.test.tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ExampleComponent } from "../ExampleComponent";

describe("ExampleComponent", () => {
  it("should render with data", async () => {
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } },
    });

    render(
      <QueryClientProvider client={queryClient}>
        <ExampleComponent />
      </QueryClientProvider>
    );

    await waitFor(() => {
      expect(screen.getByText(/example/i)).toBeInTheDocument();
    });
  });
});
```

**Testing Best Practices:**
- Use test doubles (mocks, stubs) for external dependencies
- Test happy paths, error cases, and edge cases
- Use deterministic test data (fake clocks, seeded PRNG, deterministic UUIDs)
- Maintain ≥80% coverage repo-wide, ≥90% for critical paths
- Use `describe` blocks to group related tests
- Use descriptive test names: `should [expected behavior] when [condition]`
- Clean up after tests (use `beforeEach`/`afterEach` for setup/teardown)
- Test accessibility with React Testing Library queries

## Project Status & Epics

Refer to `PROJECT_EPICS_AND_ACTIVITIES.md` for current project status:
- **Epic 1**: Profile & Settings (FR-009) - Open
- **Epic 2**: Exercise Library (FR-010) - Open
- **Epic 3**: Sharing & Community (FR-011) - Open
- **Epic 4**: Planner Completion (FR-004) - Progressing
- **Epic 5**: Logging & Import (FR-005) - Progressing
- **Epic 6**: Privacy & GDPR (NFR-002) - Progressing
- **Epic 7**: Performance Optimization (NFR-003) - Progressing
- **Epic 8**: Accessibility (NFR-004) - Progressing
- **Epic 9**: Observability (NFR-007) - Open
- **Epic 10**: Availability & Backups (NFR-005) - Progressing
- **Epic 11**: Technical Debt & Code Quality - Open
- **Epic 12**: Coach Training Unit Assignment (FR-012) - Open

## Troubleshooting Common Issues

### Dependency Version Errors
If you encounter errors like `es-errors: 1.3.0`, `debug: 4.4.3`, or `http-errors: 2.0.0`:
1. Check `package.json` for version conflicts
2. Run `pnpm update` to update dependencies
3. Check for peer dependency warnings: `pnpm install --strict-peer-dependencies`
4. Review migration guides for breaking changes
5. Use `pnpm why <package>` to understand dependency tree

### Common Error Patterns
- **404 errors**: Check route registration and middleware order
- **400 errors**: Validate input with Zod schemas before processing
- **409 errors**: Check for unique constraint violations
- **Type errors**: Ensure TypeScript strict mode compliance, no `any` types
- **Test failures**: Verify test data setup, check for flaky tests

### React/Knex/Express Specific Issues
- **React**: Use React Query for server state, Zustand for client state
- **Knex**: Always use parameterized queries (automatic), use transactions for multi-step operations
- **Express**: Use `asyncHandler` wrapper, validate with Zod, use `HttpError` for errors

## Technology-Specific Guidance

### React (37 mentions)
- Use functional components with hooks
- Implement React Query for server state management
- Use Zustand for global client state
- Follow feature-sliced architecture
- Ensure WCAG 2.1 AA compliance
- Use i18next for all user-facing text

### Knex.js (34 mentions)
- Use migrations for all schema changes
- Always use transactions for multi-step operations
- Use `snake_case` for database columns
- Add indexes for foreign keys and frequently queried columns
- Use parameterized queries (automatic with Knex)
- Use `returning("*")` for INSERT operations

### Express.js (28 mentions)
- Use `asyncHandler` wrapper for all route handlers
- Validate input with Zod schemas
- Use `HttpError` utility for consistent error responses
- Implement idempotency for state-changing operations
- Use middleware for cross-cutting concerns
- Follow REST conventions with `/api/v1/` prefix

### TypeScript (18 mentions)
- Strict mode enabled - no `any` types in public surfaces
- Use interfaces for object shapes, types for unions/intersections
- Use `import type` for type-only imports
- Use `.js` extensions in import statements (ESM compatibility)
- Prefer type inference, but be explicit for public APIs

### Docker (17 mentions)
- Use multi-stage builds for optimization
- Follow `.dockerignore` patterns
- Use health checks in Dockerfiles
- Document required environment variables
- Use Docker Compose for local development

## References
- **PRD**: `docs/1.Product_Requirements/1.Product_Requirements_Document.md`
- **TDD**: `docs/2.Technical_Design_Document/`
- **ADRs**: `docs/2.Technical_Design_Document/2.f.Architectural_Decision_Documentation/`
- **Glossary**: `docs/0.Glossary.md`
- **Contributing**: `CONTRIBUTING.md`
- **Backend Modules**: `apps/backend/src/modules/README.md`
- **Project Epics**: `PROJECT_EPICS_AND_ACTIVITIES.md`
- **Chat Analysis**: `docs/6.Implementation/cursor_chat_analysis.md` (updated based on actual usage patterns)
- **Implementation Principles**: `docs/6.Implementation/implementation_principles.md` (core implementation principles and preferences)
