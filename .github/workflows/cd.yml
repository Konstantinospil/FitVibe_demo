name: CD

on:
  push:
    branches: ["main"]
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      backend_digest:
        description: "Backend image digest (sha256:...)"
        required: true
      frontend_digest:
        description: "Frontend image digest (sha256:...)"
        required: true
      release_tag:
        description: "Semantic version to deploy (e.g. v1.2.3)"
        required: true
      previous_backend_digest:
        description: "Optional fallback backend digest for rollback"
        required: false

permissions:
  contents: read
  id-token: write

env:
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}

jobs:
  get-artifacts:
    name: Get CI Artifacts
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.head_branch == 'main' &&
       github.event.workflow_run.event == 'push')
    outputs:
      workflow_run_id: ${{ steps.find.outputs.run_id }}
    permissions:
      contents: read
      actions: read
    steps:
      - name: Find latest successful CI run
        id: find
        uses: actions/github-script@v7
        with:
          script: |
            // Determine which branch we're looking for
            const targetBranch = '${{ github.event.workflow_run.head_branch || github.ref_name }}';

            // Only look for CI runs on main or stage, never dev
            if (targetBranch === 'dev') {
              core.setFailed('CD workflow should not run for dev branch. Only CI should run for dev.');
              return;
            }

            // For production deployments (main branch), ONLY use main branch CI runs
            // Production must not use artifacts from stage branch to ensure code has been tested on main
            if (targetBranch === 'main') {
              const { data: mainRuns } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci.yml',
                branch: 'main',
                status: 'success',
                per_page: 1
              });

              if (mainRuns.workflow_runs.length > 0) {
                core.setOutput('run_id', mainRuns.workflow_runs[0].id);
                return;
              }

              // Production deployments require successful CI on main branch
              // Do NOT fallback to stage branch - this ensures production only deploys code that passed main CI
              core.setFailed(`No successful CI run found on main branch. Production deployments require successful CI on main branch. Please ensure CI has run successfully on main before deploying to production.`);
              return;
            }

            // For other branches (should not reach here since job only runs for main, but included for safety)
            core.setFailed(`Unexpected target branch: ${targetBranch}. CD workflow should only run for main branch.`);

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [get-artifacts]
    if: >
      always() &&
      (
        (github.event_name == 'workflow_dispatch') ||
        (needs.get-artifacts.result == 'success' && (github.event_name == 'push' || github.event_name == 'workflow_run'))
      ) &&
      (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'workflow_run' &&
         github.event.workflow_run.conclusion == 'success' &&
         github.event.workflow_run.event == 'push' &&
         github.event.workflow_run.head_branch != 'dev' &&
         github.event.workflow_run.head_branch != 'stage' &&
         github.event.workflow_run.head_branch == 'main') ||
        github.event_name == 'workflow_dispatch'
      )
    environment:
      name: production
    steps:
      - name: Verify workflow run repository
        if: github.event_name == 'workflow_run'
        run: |
          # SECURITY: Verify that the workflow run is from the same repository
          # This prevents checkout of untrusted code from external repositories
          if [ "${{ github.event.workflow_run.repository.full_name }}" != "${{ github.repository }}" ]; then
            echo "❌ Security check failed: Workflow run is from a different repository"
            echo "Expected: ${{ github.repository }}"
            echo "Got: ${{ github.event.workflow_run.repository.full_name }}"
            exit 1
          fi
          echo "✅ Repository verified: ${{ github.event.workflow_run.repository.full_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          persist-credentials: false
          fetch-depth: 1

      - name: Download container artifacts from CI
        if: github.event_name != 'workflow_dispatch'
        uses: actions/download-artifact@v4
        with:
          name: container-artifacts-${{ needs.get-artifacts.outputs.workflow_run_id || github.run_id }}
          path: artifacts
          run-id: ${{ needs.get-artifacts.outputs.workflow_run_id || github.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          fail-on-collision: false

      - name: Prepare deployment values
        id: vars
        shell: bash
        run: |
          # Handle manual workflow_dispatch with user-provided inputs
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Using manual deployment inputs from workflow_dispatch"
            echo "backend_image=${{ env.IMAGE_PREFIX }}/fitvibe-backend@${{ inputs.backend_digest }}" >> "$GITHUB_OUTPUT"
            echo "frontend_image=${{ env.IMAGE_PREFIX }}/fitvibe-frontend@${{ inputs.frontend_digest }}" >> "$GITHUB_OUTPUT"
            if [ -n "${{ inputs.previous_backend_digest }}" ]; then
              echo "rollback_image=${{ env.IMAGE_PREFIX }}/fitvibe-backend@${{ inputs.previous_backend_digest }}" >> "$GITHUB_OUTPUT"
            else
              echo "rollback_image=" >> "$GITHUB_OUTPUT"
            fi
            echo "release_tag=${{ inputs.release_tag }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # For push or workflow_run events, get digests from CI artifacts
          if [ "${{ github.event_name }}" == "push" ] || [ "${{ github.event_name }}" == "workflow_run" ]; then
            if [ ! -f artifacts/image-digests.txt ]; then
              echo "⚠️ Could not find image digests from CI artifacts: artifacts/image-digests.txt does not exist." >&2
              exit 1
            fi

            backend=$(grep '^backend=' artifacts/image-digests.txt | cut -d= -f2)
            frontend=$(grep '^frontend=' artifacts/image-digests.txt | cut -d= -f2)

            if [[ -z "$backend" || -z "$frontend" ]]; then
              echo "⚠️ Could not find image digests from CI artifacts: missing backend or frontend digest in artifacts/image-digests.txt." >&2
              exit 1
            fi

            echo "backend_image=$backend" >> "$GITHUB_OUTPUT"
            echo "frontend_image=$frontend" >> "$GITHUB_OUTPUT"
            echo "rollback_image=" >> "$GITHUB_OUTPUT"
            # Get version from package.json
            version=$(node -p "require('./apps/backend/package.json').version")
            echo "release_tag=v$version" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Should not reach here, but handle unknown event types gracefully
          echo "⚠️ Unsupported event type: ${{ github.event_name }}" >&2
          exit 1

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Verify backend signature
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign verify --keyless ${{ steps.vars.outputs.backend_image }}

      - name: Verify frontend signature
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign verify --keyless ${{ steps.vars.outputs.frontend_image }}

      - name: Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.SSH_KEY }}
          envs: BACKEND_IMAGE,FRONTEND_IMAGE,ROLLBACK_IMAGE,STACK_VERSION
          script: |
            set -eo pipefail

            cd ~/fitvibe

            export BACKEND_IMAGE="${BACKEND_IMAGE}"
            export FRONTEND_IMAGE="${FRONTEND_IMAGE}"
            export STACK_VERSION="${STACK_VERSION}"

            compose="docker compose -f infra/docker/prod/docker-compose.prod.yml"

            deploy_stack() {
              $compose pull backend frontend
              $compose up -d --remove-orphans
              $compose exec -T backend node dist/db/utils/migrateAll.js
              $compose exec -T backend node dist/db/utils/postDeploy.js
              $compose exec -T backend node dist/db/utils/verifyIntegrity.js
              curl -fsS http://127.0.0.1:4000/health
              curl -fsS http://127.0.0.1:4000/metrics
            }

            if ! deploy_stack; then
              echo "Deployment failed, initiating rollback..." >&2
              if [ -n "${ROLLBACK_IMAGE}" ]; then
                export BACKEND_IMAGE="${ROLLBACK_IMAGE}"
                $compose pull backend
                $compose up -d --remove-orphans
              fi
              exit 1
            fi
        env:
          BACKEND_IMAGE: ${{ steps.vars.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ steps.vars.outputs.frontend_image }}
          ROLLBACK_IMAGE: ${{ steps.vars.outputs.rollback_image }}
          STACK_VERSION: ${{ steps.vars.outputs.release_tag || inputs.release_tag }}
